1a cosa fatta: libreria per conversione in formato csr da formato matrix market. implementate tre primite cioè read matrix market, print csr usata per fare debug e capire se la conversione è andata a buon fine e free csr per liberare la memoria della matrice una volta finito. problemi: in primis il formato matrix market contiene righe di commenti caratterizzate da caratteri %, queste vanno ignorate per arrivare al punto in cui la matrice è descritta, per ignorarle ho usato fgetc invece di fgets per ragioni di ottimizzazione: fgets legge una intera riga e se contiene % la scarta, fgetc invece legge un solo carattere e se questo è % scarta il resto della riga, questo funziona solo se il primo elemento della riga è un %, il formato matrix market ce lo assicura. per costruire JA[] e AS[] abbiamo bisogno di avere una "panoramica generale" e costruire IRP[], quindi c'è bisogno prima di leggere tutto il file e poi costruire i 3 array. Per costruire IRP contiamo il numero di elementi per riga e memorizziamo il conteggio in IRP[row+1], poi si fa la somma cumulativa che converte IRP in una tabella di "puntatori" di riga. ora per riempire AS e JA usiamo IRP: creiamo un array temporaneo (row_offset nel codice) nel quale, con memcpy, copiamo il contenuto di IRP. Iteriamo sui dati originali e scriviamo:
	•	JA[pos] con l’indice di colonna.
	•	AS[pos] con il valore della matrice.
	•	Incrementiamo row_offset[row] per aggiornare la prossima posizione libera.


2a cosa fatta: nel main si è fatta una prima bozza di come creare il vettore, si è ipotizzato che sia un vettore denso composto da interi compresi tra 1 e 5 per il momento, questo si può cambiare più avanti. 

3a cosa fatta: prima implementazione di un prodotto y = Ax con conversione csr, forse va tolto dal main e messo in una classe apposita con tutti i prodotti nel formato csr quindi normale, openMP e CUDA... discutiamone poi, ho notato solo dopo che nelle slide ci stava il prodotto già fatto ho perso un pomeriggio a cercare di capire come farlo quindi lo scriveremo nel readme: la differenza tra irp e irp+1 ci da il numero di valori presenti in una riga, quindi per fare il prodotto riga * vettore x sfruttiamo questo, j = irp[i], j < irp[i+1] itera su tutti gli elementi appartenenti alla i-esima riga, fa quindi il prodotto y[i] += csr->AS[j] * x[csr->JA[j]], quindi moltiplichiamo soltanto i valori non nulli per evitare di fare iterazioni a vuoto moltiplicando per zero.

4a cosa fatta: aggiunto timer per la versione senza parallelizzazione, clock tiene conto solo di esecuzione standard quindi non si può riutilizzare ma va bene tenerlo come benchmark, siccome il timer va misurato solo sul calcolo effettivo del prodotto vettore matrice è stato messo all'interno della funzione che effettua il prodotto e viene ritornata una struct che ha il vettore risultato e i cicli di clock all'inizio e alla fine dell'operazione, così tagliamo fuori l'overhead di trasporto. inoltre si usa clock_process_cputime per evitare di misurare eventuali ritardi dovuti a interruzione del processo e rescheduling, misuriamo il tempo esatto in cui il processo è attivo sulla CPU.

5a cosa fatta: studio di suddivisione del carico nel caso di thread con openMP: idea è quella di calcolare un indice di densità della matrice, suddividere in prima battuta il carico equamente con righe adiacenti e poi spostare righe tra quelli con indice di densità maggiore a quelli con indice minore, per fare un balancing equo. così tutti i thread dovrebbero avere la certezza di fare lo stesso numero di operazioni ed impiegare lo stesso tempo ad eseguire. non è effettivamente stato implementato così, ho calcolato il nnz totale e poi ho scorso per righe fino ad assegnare a ciascun thread il nnz che deve avere (nnz tot/thr number), testing in corso.


6a cosa da fare!!!!!: bisogna fare un preprocess perché la memorizzazione in matr market potrebbe essere implicita quindi va ricostruita prima di essere tradotta. fatta: nel caso in cui fosse simmetrica ho ricostruito il triangolo inferiore invertendo gli indici riga-colonna, nel caso in cui fosse salvata con risultati impliciti ho popolato la riga dei valori con 1.


7a cosa fatta: controlli preliminari sulla matrice, così da gestire i casi di memorizzazione più complessi come matrice memorizzata in maniera simmetrica oppure come pattern, booleani dentro csr_matrix. qui bisogna lavorare, non so se può essere utile lo vedo in futuro una volta finita la parte in openMP!

tutto sotto: contare nnz come csr-m * csr-n - irp[row+1]