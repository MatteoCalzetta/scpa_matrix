1a cosa fatta: libreria per conversione in formato csr da formato matrix market. implementate tre primite cioè read matrix market, print csr usata per fare debug e capire se la conversione è andata a buon fine e free csr per liberare la memoria della matrice una volta finito. problemi: in primis il formato matrix market contiene due righe di commenti caratterizzate da caratteri %, queste vanno ignorate per arrivare al punto in cui la matrice è descritta, per ignorarle ho usato fgetc invece di fgets per ragioni di ottimizzazione: fgets legge una intera riga e se contiene % la scarta, fgetc invece legge un solo carattere e se questo è % scarta il resto della riga, questo funziona solo se il primo elemento della riga è un %, il formato matrix market ce lo assicura. per costruire JA[] e AS[] abbiamo bisogno di avere una "panoramica generale" e costruire IRP[], quindi c'è bisogno prima di leggere tutto il file e poi costruire i 3 array. Per costruire IRP contiamo il numero di elementi per riga e memorizziamo il conteggio in IRP[row+1], poi si fa la somma cumulativa che converte IRP in una tabella di "puntatori" di riga. ora per riempire AS e JA usiamo IRP: creiamo un array temporaneo (row_offset nel codice) nel quale, con memcpy, copiamo il contenuto di IRP. Iteriamo sui dati originali e scriviamo:
	•	JA[pos] con l’indice di colonna.
	•	AS[pos] con il valore della matrice.
	•	Incrementiamo row_offset[row] per aggiornare la prossima posizione libera.


2a cosa fatta: nel main si è fatta una prima bozza di come creare il vettore, si è ipotizzato che sia un vettore denso composto da interi compresi tra 1 e 5 per il momento, questo si può cambiare più avanti. 

3a cosa fatta: prima implementazione di un prodotto y = Ax con conversione csr, forse va tolto dal main e messo in una classe apposita con tutti i prodotti nel formato csr quindi normale, openMP e CUDA... discutiamone poi, ho notato solo dopo che nelle slide ci stava il prodotto già fatto ho perso un pomeriggio a cercare di capire come farlo quindi lo scriveremo nel readme: la differenza tra irp e irp+1 ci da il numero di valori presenti in una riga, quindi per fare il prodotto riga * vettore x sfruttiamo questo, j = irp[i], j < irp[i+1] itera su tutti gli elementi appartenenti alla i-esima riga, fa quindi il prodotto y[i] += csr->AS[j] * x[csr->JA[j]], quindi moltiplichiamo soltanto i valori non nulli per evitare di fare iterazioni a vuoto moltiplicando per zero.